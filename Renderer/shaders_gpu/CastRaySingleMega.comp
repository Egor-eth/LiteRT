#version 460
#extension GL_GOOGLE_include_directive : require

#include "common_gpu.h"

layout(binding = 0, set = 0) buffer data0 { uint out_color[]; }; //
layout(binding = 1, set = 0) buffer data1 { uint m_pAccelStruct_m_indices[]; }; //
layout(binding = 2, set = 0) buffer data2 { SdfObject m_pAccelStruct_m_SdfObjects[]; }; //
layout(binding = 3, set = 0) buffer data3 { SdfSBSNode m_pAccelStruct_m_SdfSBSNodes[]; }; //
layout(binding = 4, set = 0) buffer data4 { float m_pAccelStruct_m_SdfGridData[]; }; //
layout(binding = 5, set = 0) buffer data5 { uint m_pAccelStruct_m_SdfSBSData[]; }; //
layout(binding = 6, set = 0) buffer data6 { float m_pAccelStruct_m_RFGridData[]; }; //
layout(binding = 7, set = 0) buffer data7 { uvec2 m_pAccelStruct_m_geomOffsets[]; }; //
layout(binding = 8, set = 0) buffer data8 { SdfOctreeNode m_pAccelStruct_m_SdfOctreeNodes[]; }; //
layout(binding = 9, set = 0) buffer data9 { uint m_pAccelStruct_m_geomIdByInstId[]; }; //
layout(binding = 10, set = 0) buffer data10 { SdfConjunction m_pAccelStruct_m_SdfConjunctions[]; }; //
layout(binding = 11, set = 0) buffer data11 { uint m_pAccelStruct_m_SdfFrameOctreeRoots[]; }; //
layout(binding = 12, set = 0) buffer data12 { uint m_pAccelStruct_m_SdfGridOffsets[]; }; //
layout(binding = 13, set = 0) buffer data13 { uvec3 m_pAccelStruct_m_SdfGridSizes[]; }; //
layout(binding = 14, set = 0) buffer data14 { BVHNodePair m_pAccelStruct_m_allNodePairs[]; }; //
layout(binding = 15, set = 0) buffer data15 { mat4 m_pAccelStruct_m_instMatricesInv[]; }; //
layout(binding = 16, set = 0) buffer data16 { float m_pAccelStruct_m_SdfParameters[]; }; //
layout(binding = 17, set = 0) buffer data17 { BVHNode m_pAccelStruct_m_nodesTLAS[]; }; //
layout(binding = 18, set = 0) buffer data18 { uint m_pAccelStruct_m_primIndices[]; }; //
layout(binding = 19, set = 0) buffer data19 { NeuralProperties m_pAccelStruct_m_SdfNeuralProperties[]; }; //
layout(binding = 20, set = 0) buffer data20 { uint m_pAccelStruct_m_SdfSVSRoots[]; }; //
layout(binding = 21, set = 0) buffer data21 { uint m_pAccelStruct_m_SdfOctreeRoots[]; }; //
layout(binding = 22, set = 0) buffer data22 { uint m_packedXY[]; }; //
layout(binding = 23, set = 0) buffer data23 { uint m_pAccelStruct_m_bvhOffsets[]; }; //
layout(binding = 24, set = 0) buffer data24 { float m_pAccelStruct_m_RFGridScales[]; }; //
layout(binding = 25, set = 0) buffer data25 { uint m_pAccelStruct_m_RFGridSizes[]; }; //
layout(binding = 26, set = 0) buffer data26 { vec4 m_pAccelStruct_m_vertPos[]; }; //
layout(binding = 27, set = 0) buffer data27 { SdfFrameOctreeNode m_pAccelStruct_m_SdfFrameOctreeNodes[]; }; //
layout(binding = 28, set = 0) buffer data28 { uint m_pAccelStruct_m_geomTypeByGeomId[]; }; //
layout(binding = 29, set = 0) buffer data29 { BVHNode m_pAccelStruct_m_origNodes[]; }; //
layout(binding = 30, set = 0) buffer data30 { SdfSBSHeader m_pAccelStruct_m_SdfSBSHeaders[]; }; //
layout(binding = 31, set = 0) buffer data31 { uvec2 m_pAccelStruct_m_SdfSBSRemap[]; }; //
layout(binding = 32, set = 0) buffer data32 { uint m_pAccelStruct_m_ConjIndices[]; }; //
layout(binding = 33, set = 0) buffer data33 { SdfSVSNode m_pAccelStruct_m_SdfSVSNodes[]; }; //
layout(binding = 34, set = 0) buffer dataUBO { MultiRenderer_GPU_UBO_Data ubo; };

bool m_pAccelStruct_is_leaf(uint offset) {
  return (offset == 0) || ((offset & INVALID_IDX) > 0);
}

float m_pAccelStruct_eval_dist_prim(uint prim_id, vec3 p) {
  SdfObject prim = m_pAccelStruct_m_SdfObjects[prim_id];
  vec3 pos = (prim.transform * vec4(p, 1)).xyz;

  switch (prim.type)
  {
  case SDF_PRIM_SPHERE:
  {
    float r = m_pAccelStruct_m_SdfParameters[prim.params_offset + 0];
    // fprintf(stderr, "sphere %f %f %f - %f",pos.x, pos.y, pos.z, r);
    return length(pos) - r;
  }
  case SDF_PRIM_BOX:
  {
    vec3 size = vec3(m_pAccelStruct_m_SdfParameters[prim.params_offset + 0],m_pAccelStruct_m_SdfParameters[prim.params_offset + 1],m_pAccelStruct_m_SdfParameters[prim.params_offset + 2]);
    // fprintf(stderr, "box %f %f %f - %f %f %f - %f %f %f",p.x, p.y, p.z, pos.x, pos.y, pos.z, size.x, size.y, size.z);
    vec3 q = abs(pos) - size;
    return length(max(q, vec3(0.0f))) + min(max(q.x, max(q.y, q.z)), 0.0f);
  }
  case SDF_PRIM_CYLINDER:
  {
    float h = m_pAccelStruct_m_SdfParameters[prim.params_offset + 0];
    float r = m_pAccelStruct_m_SdfParameters[prim.params_offset + 1];
    vec2 d = abs(vec2(sqrt(pos.x * pos.x + pos.z * pos.z),pos.y)) - vec2(r,h);
    return min(max(d.x, d.y), 0.0f) + length(max(d, vec2(0.0f)));
  }
  case SDF_PRIM_SIREN:
  {
    float tmp_mem[2 * NEURAL_SDF_MAX_LAYER_SIZE];

    NeuralProperties prop = m_pAccelStruct_m_SdfNeuralProperties[prim.neural_id];
    uint t_ofs1 = 0;
    uint t_ofs2 = NEURAL_SDF_MAX_LAYER_SIZE;

    tmp_mem[t_ofs1 + 0] = p.x;
    tmp_mem[t_ofs1 + 1] = p.y;
    tmp_mem[t_ofs1 + 2] = p.z;

    for (int l = 0; uint(l) < prop.layer_count; l++)
    {
      uint m_ofs = prop.layers[l].offset;
      uint b_ofs = prop.layers[l].offset + prop.layers[l].in_size * prop.layers[l].out_size;
      for (int i = 0; uint(i) < prop.layers[l].out_size; i++)
      {
        tmp_mem[t_ofs2 + uint(i)] = m_pAccelStruct_m_SdfParameters[b_ofs + uint(i)];
        for (int j = 0; uint(j) < prop.layers[l].in_size; j++)
          tmp_mem[t_ofs2 + uint(i)] += tmp_mem[t_ofs1 + uint(j)] * m_pAccelStruct_m_SdfParameters[m_ofs + uint(i) * prop.layers[l].in_size + uint(j)];
        if (uint(l) < prop.layer_count - 1)
          tmp_mem[t_ofs2 + uint(i)] = sin(SIREN_W0 * tmp_mem[t_ofs2 + uint(i)]);
      }

      t_ofs2 = t_ofs1;
      t_ofs1 = (t_ofs1 + uint(NEURAL_SDF_MAX_LAYER_SIZE)) % (2 * NEURAL_SDF_MAX_LAYER_SIZE);
    }

    return tmp_mem[t_ofs1];
  }
  default:
    //fprintf(stderr, "unknown type %u", prim.type);
    //assert(false);
    break;
  }
  return -1000;
}

float m_pAccelStruct_sdf_octree_sample_mipskip_closest(uint octree_id, vec3 position, uint max_level) {
  vec3 n_pos = clamp(0.5f*(position + 1.0f), 0.0f, 1.0f);//position in current neighborhood
  float d = 1;//size of current neighborhood
  float n_distances[8];
  uint32_t n_indices[8]; //0 index means that it is "virtual" node
  uint non_leaf_nodes = 0; //how many nodes in neighborhood have children

  float prev_n_distances[8];
  uint32_t prev_n_indices[8]; //0 index means that it is "virtual" node

  //start with root's childer as a neighborhood
  uint root_id = m_pAccelStruct_m_SdfOctreeRoots[octree_id];
  uint r_idx = m_pAccelStruct_m_SdfOctreeNodes[root_id].offset;
  for (int i=0;i<8;i++)
  {
    n_distances[i] = m_pAccelStruct_m_SdfOctreeNodes[r_idx+uint(i)].value;
    n_indices[i] = r_idx+uint(i);
    non_leaf_nodes += uint32_t(!m_pAccelStruct_is_leaf(m_pAccelStruct_m_SdfOctreeNodes[r_idx+uint(i)].offset));
  }

  int level = 1;
  while (non_leaf_nodes > 0 && uint(level) <= max_level)
  {
    for (int i=0;i<8;i++)
    {
      prev_n_distances[i] = n_distances[i];
      prev_n_indices[i] = n_indices[i];
    }
    //go 1 level deeper every iteration
    non_leaf_nodes = 0;

    uvec3 idx8 = uvec3(8.0f*fract(n_pos));
    uvec3 pidx[2], chidx[2];
    vec3 n_pos_sh;
    for (int i=0;i<3;i++)
    {
      if (idx8[i] == 0)
        { pidx[0][i] = 0; chidx[0][i] = 0; pidx[1][i] = 0; chidx[1][i] = 0; n_pos_sh[i] = 0;}
      else if (idx8[i] <= 2)
        { pidx[0][i] = 0; chidx[0][i] = 0; pidx[1][i] = 0; chidx[1][i] = 1; n_pos_sh[i] = 0;}
      else if (idx8[i] <= 4)
        { pidx[0][i] = 0; chidx[0][i] = 1; pidx[1][i] = 1; chidx[1][i] = 0; n_pos_sh[i] = 0.25;}
      else if (idx8[i] <= 6)
        { pidx[0][i] = 1; chidx[0][i] = 0; pidx[1][i] = 1; chidx[1][i] = 1; n_pos_sh[i] = 0.5;}
      else //if (idx8[i] == 7)
        { pidx[0][i] = 1; chidx[0][i] = 1; pidx[1][i] = 1; chidx[1][i] = 1; n_pos_sh[i] = 0.5;}
    }
    
    //create new neighborhood
    for (uint i = 0;i<8;i++)
    {
      uvec3 n_idx = uvec3((i & 4) >> 2,(i & 2) >> 1,i & 1);
      uvec3 cur_pidx = uvec3(pidx[n_idx[0]][0],pidx[n_idx[1]][1],pidx[n_idx[2]][2]);
      uvec3 cur_chidx = uvec3(chidx[n_idx[0]][0],chidx[n_idx[1]][1],chidx[n_idx[2]][2]);

      uint p_index = 4*cur_pidx.x + 2*cur_pidx.y + cur_pidx.z;
      if (prev_n_indices[p_index] > 0 &&                //p_index is a real node
          !m_pAccelStruct_is_leaf(m_pAccelStruct_m_SdfOctreeNodes[prev_n_indices[p_index]].offset))    //p_index has children
      {
        uint ch_index = m_pAccelStruct_m_SdfOctreeNodes[prev_n_indices[p_index]].offset + 4*cur_chidx.x + 2*cur_chidx.y + cur_chidx.z;
        n_distances[i] = m_pAccelStruct_m_SdfOctreeNodes[ch_index].value;
        n_indices[i] = ch_index;      
        non_leaf_nodes += uint32_t(!m_pAccelStruct_is_leaf(m_pAccelStruct_m_SdfOctreeNodes[ch_index].offset));
      }
      else                                              //p_index is a leaf node
      {
        n_distances[i] = prev_n_distances[p_index];
        n_indices[i] = 0;   
      }
    }

    n_pos = fract(2.0f*(n_pos - n_pos_sh));
    d /= 2;

    level++;
  }

  //bilinear sampling
  vec3 dp = clamp(2.0f*n_pos - vec3(0.5,0.5,0.5), 0.0f, 1.0f);
  return (1-dp.x)*(1-dp.y)*(1-dp.z)*n_distances[0] + 
         (1-dp.x)*(1-dp.y)*(  dp.z)*n_distances[1] + 
         (1-dp.x)*(  dp.y)*(1-dp.z)*n_distances[2] + 
         (1-dp.x)*(  dp.y)*(  dp.z)*n_distances[3] + 
         (  dp.x)*(1-dp.y)*(1-dp.z)*n_distances[4] + 
         (  dp.x)*(1-dp.y)*(  dp.z)*n_distances[5] + 
         (  dp.x)*(  dp.y)*(1-dp.z)*n_distances[6] + 
         (  dp.x)*(  dp.y)*(  dp.z)*n_distances[7];
}

float m_pAccelStruct_sdf_octree_sample_closest(uint octree_id, vec3 position, uint max_level) {
  vec3 pos = clamp(0.5f*(position + 1.0f), 0.0f, 1.0f);
  uint idx = m_pAccelStruct_m_SdfOctreeRoots[octree_id];
  float d = 1;
  uint level = 0;
  vec3 p = vec3(0,0,0);
  while (m_pAccelStruct_m_SdfOctreeNodes[idx].offset != 0 && level <= max_level)
  {
    vec3 pindf = pos/d - p;
    uint ch_index = 4*uint32_t(pindf.x >= 0.5) + 2*uint32_t(pindf.y >= 0.5) + uint32_t(pindf.z >= 0.5);
    //printf("%u pindf %f %f %f %u\n",idx, pindf.x, pindf.y, pindf.z, ch_index);
    idx = m_pAccelStruct_m_SdfOctreeNodes[idx].offset + ch_index;
    d = d/2;
    p = 2*p + vec3((ch_index & 4) >> 2,(ch_index & 2) >> 1,ch_index & 1);
    level++;
  }
  //printf("\n");
  //printf("%u last pindf \n",idx);

  return m_pAccelStruct_m_SdfOctreeNodes[idx].value;
}

float m_pAccelStruct_sdf_octree_sample_mipskip_3x3(uint octree_id, vec3 position, uint max_level) {
  uint CENTER = 9 + 3 + 1;
  float EPS = 1e-6;
  SDONeighbor neighbors[27];
  SDONeighbor new_neighbors[27];


  vec3 n_pos = clamp(0.5f*(position + 1.0f), EPS, 1.0f-EPS);//position in current neighborhood
  float d = 1;//size of current neighborhood
  uint level = 0;
  uint root_id = m_pAccelStruct_m_SdfOctreeRoots[octree_id];
  for (int i=0;i<27;i++)
  {
    neighbors[i].node = m_pAccelStruct_m_SdfOctreeNodes[root_id];
    neighbors[i].overshoot = 0;
    if (i/9 == 0) neighbors[i].overshoot |= X_L;
    else if (i/9 == 2) neighbors[i].overshoot |= X_H;
    if (i/3%3 == 0) neighbors[i].overshoot |= Y_L;
    else if (i/3%3 == 2) neighbors[i].overshoot |= Y_H;
    if (i%3 == 0) neighbors[i].overshoot |= Z_L;
    else if (i%3 == 2) neighbors[i].overshoot |= Z_H;
  }
  neighbors[CENTER].overshoot = 0;

  while (!m_pAccelStruct_is_leaf(neighbors[CENTER].node.offset) && level < max_level)
  {
    ivec3 ch_shift = ivec3(n_pos.x >= 0.5,n_pos.y >= 0.5,n_pos.z >= 0.5);

    for (int i=0;i<27;i++)
    {
      ivec3 n_offset = ivec3(i/9,i/3%3,i%3); //[0,2]^3
      ivec3 p_idx = (n_offset + ch_shift + 1) / 2;
      ivec3 ch_idx = (n_offset + ch_shift + 1) - 2*p_idx;
      uint p_offset = 9*p_idx.x + 3*p_idx.y + p_idx.z;
    
      if (m_pAccelStruct_is_leaf(neighbors[p_offset].node.offset)) //resample
      {
        vec3 rs_pos = 0.5f*vec3(2*p_idx + ch_idx) - 1.0f + 0.25f;//in [-1,2]^3

        //sample neighborhood
        vec3 qx = clamp(vec3(0.5-rs_pos.x,min(0.5f + rs_pos.x, 1.5f - rs_pos.x),-0.5+rs_pos.x),0.0f,1.0f);
        vec3 qy = clamp(vec3(0.5-rs_pos.y,min(0.5f + rs_pos.y, 1.5f - rs_pos.y),-0.5+rs_pos.y),0.0f,1.0f);
        vec3 qz = clamp(vec3(0.5-rs_pos.z,min(0.5f + rs_pos.z, 1.5f - rs_pos.z),-0.5+rs_pos.z),0.0f,1.0f);

        float res = 0.0;
        for (int i=0;i<3;i++)
          for (int j=0;j<3;j++)
            for (int k=0;k<3;k++)
              res += qx[i]*qy[j]*qz[k]*neighbors[9*i + 3*j + k].node.value;
        //sample neighborhood end

        new_neighbors[i].node.value = res;
        new_neighbors[i].node.offset = 0;
        new_neighbors[i].overshoot = 0;
      }
      else if (neighbors[p_offset].overshoot == 0) //pick child node
      {
        uint ch_offset = 4*ch_idx.x + 2*ch_idx.y + ch_idx.z;
        uint off = neighbors[p_offset].node.offset;
        new_neighbors[i].node = m_pAccelStruct_m_SdfOctreeNodes[off + ch_offset];
        new_neighbors[i].overshoot = 0;
      }
      else //pick child node, but mind the overshoot
      {
        /**/
        ivec3 ch_idx_overshoot = ch_idx;
        uint osh = neighbors[p_offset].overshoot;
        uint new_osh = 0;
        if (((osh&X_L) > 0) && p_idx.x == 0) 
          {ch_idx_overshoot.x = 0; new_osh |= X_L; }
        else if (((osh&X_H) > 0) && p_idx.x == 2) 
          {ch_idx_overshoot.x = 1; new_osh |= X_H; }
        if (((osh&Y_L) > 0) && p_idx.y == 0) 
          {ch_idx_overshoot.y = 0; new_osh |= Y_L; }
        else if (((osh&Y_H) > 0) && p_idx.y == 2) 
          {ch_idx_overshoot.y = 1; new_osh |= Y_H; }
        if (((osh&Z_L) > 0) && p_idx.z == 0) 
          {ch_idx_overshoot.z = 0; new_osh |= Z_L; }
        else if (((osh&Z_H) > 0) && p_idx.z == 2) 
          {ch_idx_overshoot.z = 1; new_osh |= Z_H; }

        uint ch_offset = 4*ch_idx_overshoot.x + 2*ch_idx_overshoot.y + ch_idx_overshoot.z;
        uint off = neighbors[p_offset].node.offset;
        new_neighbors[i].node = m_pAccelStruct_m_SdfOctreeNodes[off + ch_offset];
        new_neighbors[i].overshoot = new_osh;
      }
    }

    for (int i=0;i<27;i++)
      neighbors[i] = new_neighbors[i];

    n_pos = fract(2.0f*(n_pos - 0.5f*vec3(ch_shift)));
    d /= 2;
    level++;
  }

  //sample neighborhood
  vec3 qx = clamp(vec3(0.5-n_pos.x,min(0.5f + n_pos.x, 1.5f - n_pos.x),-0.5+n_pos.x),0.0f,1.0f);
  vec3 qy = clamp(vec3(0.5-n_pos.y,min(0.5f + n_pos.y, 1.5f - n_pos.y),-0.5+n_pos.y),0.0f,1.0f);
  vec3 qz = clamp(vec3(0.5-n_pos.z,min(0.5f + n_pos.z, 1.5f - n_pos.z),-0.5+n_pos.z),0.0f,1.0f);

  float res = 0.0;
  for (int i=0;i<3;i++)
    for (int j=0;j<3;j++)
      for (int k=0;k<3;k++)
        res += qx[i]*qy[j]*qz[k]*neighbors[9*i + 3*j + k].node.value;
  return res;
  //sample neighborhood end
}

float m_pAccelStruct_eval_dist_sdf_conjunction(uint conj_id, vec3 p) {
  SdfConjunction conj = m_pAccelStruct_m_SdfConjunctions[conj_id];
  float conj_d = -1e6;
  for (uint pid = conj.offset; pid < conj.offset + conj.size; pid++)
  {
    float prim_d = m_pAccelStruct_m_SdfObjects[pid].distance_mult * m_pAccelStruct_eval_dist_prim(pid, p) +
                   m_pAccelStruct_m_SdfObjects[pid].distance_add;
    conj_d = max(conj_d, m_pAccelStruct_m_SdfObjects[pid].complement == 1 ? -prim_d : prim_d);
  }
  return conj_d;
}

float m_pAccelStruct_eval_distance_sdf_octree(uint octree_id, vec3 position, uint max_level) {
  switch (ubo.m_pAccelStruct_m_preset.sdf_octree_sampler)
  {
  case SDF_OCTREE_SAMPLER_MIPSKIP_3X3:
    return m_pAccelStruct_sdf_octree_sample_mipskip_3x3(octree_id, position, max_level);
    break;
  case SDF_OCTREE_SAMPLER_MIPSKIP_CLOSEST:
    return m_pAccelStruct_sdf_octree_sample_mipskip_closest(octree_id, position, max_level);
    break;
    case SDF_OCTREE_SAMPLER_CLOSEST:
    return m_pAccelStruct_sdf_octree_sample_closest(octree_id, position, max_level);
    break;
  default:
    return 1e6;
    break;
  }
}

float m_pAccelStruct_eval_distance_sdf_grid(uint grid_id, vec3 pos) {
  uint off = m_pAccelStruct_m_SdfGridOffsets[grid_id];
  uvec3 size = m_pAccelStruct_m_SdfGridSizes[grid_id];

  //bbox for grid is a unit cube
  vec3 grid_size_f = vec3(size);
  vec3 vox_f = grid_size_f*((pos-vec3(-1,-1,-1))/vec3(2,2,2)) - vec3(0.5,0.5,0.5);
  vox_f = min(max(vox_f, vec3(0.0f)), grid_size_f - vec3(1e-5f));
  uvec3 vox_u = uvec3(vox_f);
  vec3 dp = vox_f - vec3(vox_u);

  //trilinear sampling
  float res = 0.0;
  if (vox_u.x < size.x-1 && vox_u.y < size.y-1 && vox_u.z < size.z-1)
  {
    for (int i=0;i<2;i++)
    {
      for (int j=0;j<2;j++)
      {
        for (int k=0;k<2;k++)
        {
          float qx = (1 - dp.x + float(i)*(2*dp.x-1));
          float qy = (1 - dp.y + float(j)*(2*dp.y-1));
          float qz = (1 - dp.z + float(k)*(2*dp.z-1));   
          res += qx*qy*qz*m_pAccelStruct_m_SdfGridData[off + (vox_u.z + uint(k))*size.x*size.y + (vox_u.y + uint(j))*size.x + (vox_u.x + uint(i))];   
        }      
      }
    }
  }
  else
  {
    res += m_pAccelStruct_m_SdfGridData[off + (vox_u.z)*size.x*size.y + (vox_u.y)*size.x + (vox_u.x)]; 
  }
  
  return res;
}

float m_pAccelStruct_eval_distance_sdf_frame_octree(uint octree_id, vec3 position) {
  vec3 pos = clamp(0.5f*(position + 1.0f), 0.0f, 1.0f);
  uint idx = m_pAccelStruct_m_SdfFrameOctreeRoots[octree_id];
  float d = 1;
  vec3 p = vec3(0,0,0);
  vec3 dp = pos;
  while (m_pAccelStruct_m_SdfFrameOctreeNodes[idx].offset != 0)
  {
    uint ch_index = 4*uint32_t(dp.x >= 0.5) + 2*uint32_t(dp.y >= 0.5) + uint32_t(dp.z >= 0.5);
    //printf("%u dp %f %f %f %u\n",idx, dp.x, dp.y, dp.z, ch_index);
    idx = m_pAccelStruct_m_SdfFrameOctreeNodes[idx].offset + ch_index;
    d = d/2;
    p = 2*p + vec3((ch_index & 4) >> 2,(ch_index & 2) >> 1,ch_index & 1);
    dp = pos/d - p;
  }
  //printf("\n");
  //printf("%u last dp \n",idx);

  //bilinear sampling
  return (1-dp.x)*(1-dp.y)*(1-dp.z)*m_pAccelStruct_m_SdfFrameOctreeNodes[idx].values[0] + 
         (1-dp.x)*(1-dp.y)*(  dp.z)*m_pAccelStruct_m_SdfFrameOctreeNodes[idx].values[1] + 
         (1-dp.x)*(  dp.y)*(1-dp.z)*m_pAccelStruct_m_SdfFrameOctreeNodes[idx].values[2] + 
         (1-dp.x)*(  dp.y)*(  dp.z)*m_pAccelStruct_m_SdfFrameOctreeNodes[idx].values[3] + 
         (  dp.x)*(1-dp.y)*(1-dp.z)*m_pAccelStruct_m_SdfFrameOctreeNodes[idx].values[4] + 
         (  dp.x)*(1-dp.y)*(  dp.z)*m_pAccelStruct_m_SdfFrameOctreeNodes[idx].values[5] + 
         (  dp.x)*(  dp.y)*(1-dp.z)*m_pAccelStruct_m_SdfFrameOctreeNodes[idx].values[6] + 
         (  dp.x)*(  dp.y)*(  dp.z)*m_pAccelStruct_m_SdfFrameOctreeNodes[idx].values[7];
}

vec2 m_pAccelStruct_box_intersects(in vec3 min_pos, in vec3 max_pos, in vec3 origin, in vec3 dir) {
  vec3 safe_dir = sign(dir) * max(vec3(1e-9f), abs(dir));
  vec3 tMin = (min_pos - origin) / safe_dir;
  vec3 tMax = (max_pos - origin) / safe_dir;
  vec3 t1 = min(tMin, tMax);
  vec3 t2 = max(tMin, tMax);
  float tNear = max(t1.x, max(t1.y, t1.z));
  float tFar = min(t2.x, min(t2.y, t2.z));

  return vec2(tNear,tFar);
}

float m_pAccelStruct_eval_distance_sdf(uint type, uint sdf_id, vec3 pos) {
  float val = 1000;
  switch (type)
  {
#ifndef LITERT_MINI
  case TYPE_SDF_PRIMITIVE:
    val = m_pAccelStruct_eval_dist_sdf_conjunction(sdf_id, pos);
    break;
#endif
  case TYPE_SDF_GRID:
    val = m_pAccelStruct_eval_distance_sdf_grid(sdf_id, pos);
    break;
  case TYPE_SDF_OCTREE:
    val = m_pAccelStruct_eval_distance_sdf_octree(sdf_id, pos, 1000);
    break;
  case TYPE_SDF_FRAME_OCTREE:
    val = m_pAccelStruct_eval_distance_sdf_frame_octree(sdf_id, pos);
    break;
  default:
    break;
  }
  return val;
}

void m_pAccelStruct_lerpCell(const int idx0, const int idx1, const float t, inout float memory[28]) {
  for (int i = 0; i < 28; i++)
    memory[i] = mix(m_pAccelStruct_m_RFGridData[idx0 + i], m_pAccelStruct_m_RFGridData[idx1 + i], t);
}

void m_pAccelStruct_RayGridIntersection(vec3 ray_pos, vec3 ray_dir, vec3 bbMin, vec3 bbMax, uint gridSize, vec3 p, vec3 lastP, inout float throughput, inout vec3 colour) {
  vec3 coords01 = (p - bbMin) / (bbMax - bbMin);
  vec3 coords = coords01 * float((gridSize));

  ivec3 nearCoords = clamp(ivec3(ivec3(coords)), ivec3(0), ivec3(gridSize - 1));
  ivec3 farCoords = clamp(ivec3(ivec3(coords)) + ivec3(1), ivec3(0), ivec3(gridSize - 1));

  vec3 lerpFactors = coords - vec3(vec3(nearCoords));

  float xy00[28];
  float xy10[28];
  float xy01[28];
  float xy11[28];
  
  m_pAccelStruct_lerpCell(indexGrid(nearCoords[0], nearCoords[1], nearCoords[2], int(gridSize)), indexGrid(farCoords[0], nearCoords[1], nearCoords[2], int(gridSize)), lerpFactors.x, xy00);
  m_pAccelStruct_lerpCell(indexGrid(nearCoords[0], farCoords[1], nearCoords[2], int(gridSize)), indexGrid(farCoords[0], farCoords[1], nearCoords[2], int(gridSize)), lerpFactors.x, xy10);
  m_pAccelStruct_lerpCell(indexGrid(nearCoords[0], nearCoords[1], farCoords[2], int(gridSize)), indexGrid(farCoords[0], nearCoords[1], farCoords[2], int(gridSize)), lerpFactors.x, xy01);
  m_pAccelStruct_lerpCell(indexGrid(nearCoords[0], farCoords[1], farCoords[2], int(gridSize)), indexGrid(farCoords[0], farCoords[1], farCoords[2], int(gridSize)), lerpFactors.x, xy11);

  float xyz0[28];
  float xyz1[28];
  lerpCellf(xy00, xy10, lerpFactors.y, xyz0);
  lerpCellf(xy01, xy11, lerpFactors.y, xyz1);

  float gridVal[28];
  lerpCellf(xyz0, xyz1, lerpFactors.z, gridVal);

  // relu
  if (gridVal[0] < 0.0)
    gridVal[0] = 0.0;

  // for (size_t i = 0; i < 28; i++)
    // std::cout << (&grid[indexGrid(nearCoords[0], nearCoords[1], nearCoords[2], gridSize)])[i] << ' ';
  // std::cout << std::endl;

  float dist = length(p - lastP);
  if (dist > sqrt(3) / float(gridSize))
      dist -= (int((dist * float(gridSize))) - 1) / float(gridSize);

  float tr = exp(-gridVal[0] * m_pAccelStruct_m_RFGridScales[0] * dist);

  // std::cout << tr << ' ' << gridVal[0] << ' ' << length(p - lastP) << ' ' << gridSize << std::endl;

  // float3 RGB = float3(1.0f);
  vec3 RGB = vec3(min(max(eval_sh(gridVal, ray_dir, 1), 0.0f), 1.0f),min(max(eval_sh(gridVal, ray_dir, 10), 0.0f), 1.0f),min(max(eval_sh(gridVal, ray_dir, 19), 0.0f), 1.0f));
  colour = colour + throughput * (1 - tr) * RGB;
  
  throughput *= tr;
}

SdfHit m_pAccelStruct_sdf_sphere_tracing(uint type, uint sdf_id, in vec3 min_pos, in vec3 max_pos, in vec3 pos, in vec3 dir, bool need_norm) {
  const float EPS = 1e-5;

  SdfHit hit;
  hit.hit_pos = vec4(0,0,0,-1);
  hit.hit_norm = vec4(1,0,0,0);
  vec2 tNear_tFar = m_pAccelStruct_box_intersects(min_pos, max_pos, pos, dir);
  float t = tNear_tFar.x;
  float tFar = tNear_tFar.y;
  if (t > tFar)
    return hit;
  
  int iter = 0;
  float d = m_pAccelStruct_eval_distance_sdf(type, sdf_id, pos + t * dir);
  while (iter < 1000 && d > EPS && t < tFar)
  {
    t += d + EPS;
    d = m_pAccelStruct_eval_distance_sdf(type, sdf_id, pos + t * dir);
    iter++;
  }

  if (d > EPS)
    return hit;

  vec3 p0 = pos + t * dir;
  vec3 norm = vec3(0,0,1);
  if (need_norm)
  {
    const float h = 0.001;
    float ddx = (m_pAccelStruct_eval_distance_sdf(type, sdf_id, p0 + vec3(h,0,0)) -
                 m_pAccelStruct_eval_distance_sdf(type, sdf_id, p0 + vec3(-h,0,0))) /
                (2 * h);
    float ddy = (m_pAccelStruct_eval_distance_sdf(type, sdf_id, p0 + vec3(0,h,0)) -
                 m_pAccelStruct_eval_distance_sdf(type, sdf_id, p0 + vec3(0,-h,0))) /
                (2 * h);
    float ddz = (m_pAccelStruct_eval_distance_sdf(type, sdf_id, p0 + vec3(0,0,h)) -
                 m_pAccelStruct_eval_distance_sdf(type, sdf_id, p0 + vec3(0,0,-h))) /
                (2 * h);

    norm = normalize(vec3(ddx,ddy,ddz));
    // fprintf(stderr, "st %d (%f %f %f)\n", iter, surface_normal->x, surface_normal->y, surface_normal->z);
  }
  // fprintf(stderr, "st %d (%f %f %f)", iter, p0.x, p0.y, p0.z);
  hit.hit_pos = vec4(p0, 1);
  hit.hit_norm = vec4(norm, float(iter));
  return hit;
}

float m_pAccelStruct_eval_dist_trilinear(const float values[8], vec3 dp) {
  return (1-dp.x)*(1-dp.y)*(1-dp.z)*values[0] + 
         (1-dp.x)*(1-dp.y)*(  dp.z)*values[1] + 
         (1-dp.x)*(  dp.y)*(1-dp.z)*values[2] + 
         (1-dp.x)*(  dp.y)*(  dp.z)*values[3] + 
         (  dp.x)*(1-dp.y)*(1-dp.z)*values[4] + 
         (  dp.x)*(1-dp.y)*(  dp.z)*values[5] + 
         (  dp.x)*(  dp.y)*(1-dp.z)*values[6] + 
         (  dp.x)*(  dp.y)*(  dp.z)*values[7];
}

void m_pAccelStruct_IntersectAllSdfsInLeaf(const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, uint a_start, uint a_count, inout CRT_Hit pHit) {

  uint type = m_pAccelStruct_m_geomTypeByGeomId[geomId];
  uint sdfId = 0;
  uint primId = 0;

  vec3 min_pos = vec3(0,0,0), max_pos = vec3(0,0,0);

  switch (type)
  {
#ifndef LITERT_MINI
  case TYPE_SDF_PRIMITIVE:
    sdfId = m_pAccelStruct_m_ConjIndices[m_pAccelStruct_m_geomOffsets[geomId].x + a_start];
    primId = sdfId;
    min_pos = m_pAccelStruct_m_SdfConjunctions[sdfId].min_pos.xyz;
    max_pos = m_pAccelStruct_m_SdfConjunctions[sdfId].max_pos.xyz;
    break;
#endif
  case TYPE_SDF_GRID:
  case TYPE_SDF_OCTREE:
    sdfId = m_pAccelStruct_m_geomOffsets[geomId].x;
    primId = 0;
    min_pos = vec3(-1,-1,-1);
    max_pos = vec3(1,1,1);
    break;
  case TYPE_SDF_FRAME_OCTREE:
    sdfId =  m_pAccelStruct_m_geomOffsets[geomId].x;

    if (ubo.m_pAccelStruct_m_preset.sdf_frame_octree_blas == SDF_OCTREE_BLAS_NO)
    {
      primId = 0;
      min_pos = vec3(-1,-1,-1);
      max_pos = vec3(1,1,1);
    }
    else if (ubo.m_pAccelStruct_m_preset.sdf_frame_octree_blas == SDF_OCTREE_BLAS_DEFAULT)
    {
      primId = m_pAccelStruct_m_origNodes[a_start].leftOffset;
      min_pos = m_pAccelStruct_m_origNodes[a_start].boxMin;
      max_pos = m_pAccelStruct_m_origNodes[a_start].boxMax;
    }
    break;
  default:
    break;
  }

  float l = length(ray_dir);
  vec3 dir = ray_dir/l;
  SdfHit hit = m_pAccelStruct_sdf_sphere_tracing(type, sdfId, min_pos, max_pos, ray_pos, dir, ubo.m_pAccelStruct_m_preset.need_normal > 0);
  if (hit.hit_pos.w > 0)
  {
    float t = length(hit.hit_pos.xyz-ray_pos)/l;
    if (t > tNear && t < pHit.t)
    {
      pHit.t         = t;
      pHit.primId    = primId;
      pHit.instId    = instId;
      pHit.geomId    = geomId | (type << SH_TYPE);  
      pHit.coords[0] = 0;
      pHit.coords[1] = 0;
      pHit.coords[2] = hit.hit_norm.x;
      pHit.coords[3] = hit.hit_norm.y;

      if (ubo.m_pAccelStruct_m_preset.visualize_stat == VISUALIZE_STAT_SPHERE_TRACE_ITERATIONS)
        pHit.primId = uint32_t(hit.hit_norm.w);
    }
  }
}

void m_pAccelStruct_OctreeNodeIntersect(uint type, const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, uint a_start, uint a_count, inout CRT_Hit pHit) {
  const float EPS = 1e-6;
  const uint ST_max_iters = 256;

  float values[8];
  uint nodeId,  primId;
  float d, qFar;
  vec2 fNearFar;
  vec3 start_q;
  vec3 min_pos,  max_pos;

  if (type == TYPE_SDF_FRAME_OCTREE)
  {
    uint sdfId = m_pAccelStruct_m_geomOffsets[geomId].x;
    primId = m_pAccelStruct_m_origNodes[a_start].leftOffset;
    nodeId = primId + m_pAccelStruct_m_SdfFrameOctreeRoots[sdfId];
    min_pos = m_pAccelStruct_m_origNodes[a_start].boxMin;
    max_pos = m_pAccelStruct_m_origNodes[a_start].boxMax;
    vec3 size = max_pos - min_pos;

    for (int i=0;i<8;i++)
      values[i] = m_pAccelStruct_m_SdfFrameOctreeNodes[nodeId].values[i];

    fNearFar = RayBoxIntersection2(ray_pos, SafeInverse(ray_dir), min_pos, max_pos);
    vec3 start_pos = ray_pos + fNearFar.x*ray_dir;
    d = max(size.x, max(size.y, size.z));
    start_q = (start_pos - min_pos)/(2.0f*d);
    qFar = (fNearFar.y - fNearFar.x) / (2.0f * d);
  }
  else if (type == TYPE_SDF_SVS)
  {
    uint sdfId = m_pAccelStruct_m_geomOffsets[geomId].x;
    primId = a_start;
    nodeId = primId + m_pAccelStruct_m_SdfSVSRoots[sdfId];

    float px = m_pAccelStruct_m_SdfSVSNodes[nodeId].pos_xy >> 16;
    float py = m_pAccelStruct_m_SdfSVSNodes[nodeId].pos_xy & 0x0000FFFF;
    float pz = m_pAccelStruct_m_SdfSVSNodes[nodeId].pos_z_lod_size >> 16;
    float sz = m_pAccelStruct_m_SdfSVSNodes[nodeId].pos_z_lod_size & 0x0000FFFF;
    float d_max = 2*1.41421356f/sz;

    min_pos = vec3(-1,-1,-1) + 2.0f*vec3(px,py,pz)/sz;
    max_pos = min_pos + 2.0f*vec3(1,1,1)/sz;
    vec3 size = max_pos - min_pos;

    for (int i=0;i<8;i++)
      values[i] = -d_max + 2*d_max*(1.0/255.0f)*((m_pAccelStruct_m_SdfSVSNodes[nodeId].values[i/4] >> (8*(i%4))) & 0xFF);

    fNearFar = RayBoxIntersection2(ray_pos, SafeInverse(ray_dir), min_pos, max_pos);
    vec3 start_pos = ray_pos + fNearFar.x*ray_dir;
    d = max(size.x, max(size.y, size.z));
    start_q = (start_pos - min_pos)/(2.0f*d);
    qFar = (fNearFar.y - fNearFar.x) / (2.0f * d);
  }
  else //if (type == TYPE_SDF_SBS)
  {
    uint sdfId = m_pAccelStruct_m_geomOffsets[geomId].x;
    primId = a_start; //id of bbox in BLAS
    nodeId = m_pAccelStruct_m_SdfSBSRemap[primId + m_pAccelStruct_m_geomOffsets[geomId].y].x; //id of node (brick) in SBS
    uint voxelId = m_pAccelStruct_m_SdfSBSRemap[primId + m_pAccelStruct_m_geomOffsets[geomId].y].y;
    SdfSBSHeader header = m_pAccelStruct_m_SdfSBSHeaders[sdfId];
    uvec3 voxelPos = uvec3(voxelId/(header.v_size*header.v_size),voxelId/header.v_size%header.v_size,voxelId%header.v_size);

    float px = m_pAccelStruct_m_SdfSBSNodes[nodeId].pos_xy >> 16;
    float py = m_pAccelStruct_m_SdfSBSNodes[nodeId].pos_xy & 0x0000FFFF;
    float pz = m_pAccelStruct_m_SdfSBSNodes[nodeId].pos_z_lod_size >> 16;
    float sz = m_pAccelStruct_m_SdfSBSNodes[nodeId].pos_z_lod_size & 0x0000FFFF;

    min_pos = vec3(-1,-1,-1) + 2.0f*(vec3(px,py,pz)/sz + vec3(voxelPos)/(sz*float(header.brick_size)));
    max_pos = min_pos + 2.0f*vec3(1,1,1)/(sz*float(header.brick_size));
    vec3 size = max_pos - min_pos;

    //TODO: make it works with brick_size > 1
    uint v_off = m_pAccelStruct_m_SdfSBSNodes[nodeId].data_offset;
    uint vals_per_int = 4/header.bytes_per_value; 
    uint bits = 8*header.bytes_per_value;
    uint max_val = header.bytes_per_value == 4 ? 0xFFFFFFFF : ((1 << bits) - 1);
    float d_max = 2*1.41421356f/sz;
    float mult = 2*d_max/float(max_val);
    for (int i=0;i<8;i++)
    {
      uvec3 vPos = voxelPos + uvec3((i & 4) >> 2,(i & 2) >> 1,i & 1);
      uint vId = vPos.x*header.v_size*header.v_size + vPos.y*header.v_size + vPos.z;
      values[i] = -d_max + mult*((m_pAccelStruct_m_SdfSBSData[v_off + vId/vals_per_int] >> (bits*(vId%vals_per_int))) & max_val);
    }

    fNearFar = RayBoxIntersection2(ray_pos, SafeInverse(ray_dir), min_pos, max_pos);
    vec3 start_pos = ray_pos + fNearFar.x*ray_dir;
    d = max(size.x, max(size.y, size.z));
    start_q = (start_pos - min_pos)/(2.0f*d);
    qFar = (fNearFar.y - fNearFar.x) / (2.0f * d);
  }

  float t = 0;
  bool hit = false;
  uint iter = 0;

  float start_dist = m_pAccelStruct_eval_dist_trilinear(values, start_q);
  if (start_dist <= EPS || ubo.m_pAccelStruct_m_preset.sdf_frame_octree_intersect == SDF_OCTREE_NODE_INTERSECT_BBOX)
  {
    hit = true;
  }
  else if (ubo.m_pAccelStruct_m_preset.sdf_frame_octree_intersect == SDF_OCTREE_NODE_INTERSECT_ST)
  {
    float dist = start_dist;
    vec3 pp0 = start_q + t * ray_dir;

    while (t < qFar && dist > EPS && iter < ST_max_iters)
    {
      t += dist / (2.0f * d);
      dist = m_pAccelStruct_eval_dist_trilinear(values, start_q + t * ray_dir);
      vec3 pp = start_q + t * ray_dir;
      iter++;
    }
    hit = (dist <= EPS);
  }
  else //if (m_preset.sdf_frame_octree_intersect == SDF_OCTREE_NODE_INTERSECT_ANALYTIC ||
       //    m_preset.sdf_frame_octree_intersect == SDF_OCTREE_NODE_INTERSECT_NEWTON)
  {
    //finding exact intersection between surface sdf(x,y,z) = 0 and ray
    // based on paper "Ray Tracing of Signed Distance Function Grids, 
    // Journal of Computer Graphics Techniques (JCGT), vol. 11, no. 3, 94-113, 2022"
    // http://jcgt.org/published/0011/03/06/

    // define values and constants as proposed in paper
    float s000 = values[0]/d;
    float s001 = values[1]/d;
    float s010 = values[2]/d;
    float s011 = values[3]/d;
    float s100 = values[4]/d;
    float s101 = values[5]/d;
    float s110 = values[6]/d;
    float s111 = values[7]/d;

    float a = s101-s001;

    float k0 = s000;
    float k1 = s100-s000;
    float k2 = s010-s000;
    float k3 = s110-s010-k1;
    float k4 = k0-s001;
    float k5 = k1-a;
    float k6 = k2-(s011-s001);
    float k7 = k3-(s111-s011-a);

    vec3 o = start_q;
    vec3 d = ray_dir;

    float m0 = o.x*o.y;
    float m1 = d.x*d.y;
    float m2 = o.x*d.y + o.y*d.x;
    float m3 = k5*o.z - k1;
    float m4 = k6*o.z - k2;
    float m5 = k7*o.z - k3;

    float c0 = (k4*o.z - k0) + o.x*m3 + o.y*m4 + m0*m5;
    float c1 = d.x*m3 + d.y*m4 + m2*m5 + d.z*(k4 + k5*o.x + k6*o.y + k7*m0);
    float c2 = m1*m5 + d.z*(k5*d.x + k6*d.y + k7*m2);
    float c3 = k7*m1*d.z;

    // the surface is defined by equation c3*t^3 + c2*t^2 + c1*t + c0 = 0;
    // solve this equation analytically or numerically using the Newton's method
    // see "Numerical Recipes - The Art of Scientific Computing - 3rd Edition" for details

    if (ubo.m_pAccelStruct_m_preset.sdf_frame_octree_intersect == SDF_OCTREE_NODE_INTERSECT_ANALYTIC)
    {
      float x1 = 1000;
      float x2 = 1000;
      float x3 = 1000;
      uint type = 0;
      if (abs(c3) > 1e-2)
      {
        type = 3;
        //it is a cubic equation, transform it to x^3 + a*x^2 + b*x + c = 0
        //use Vieta method to obtain 3 or 1 real roots
        float a = c2/c3;
        float b = c1/c3;
        float c = c0/c3;   

        float Q = (a*a - 3*b)/9;
        float R = (2*a*a - 9*a*b + 27*c)/54;
        float Q3 = Q*Q*Q;

        if (R*R < Q3) //equation has three real roots
        {
          float theta = acos(R/sqrt(Q3));
          x1 = -2*sqrt(Q)*cos(theta/3) - a/3;
          x2 = -2*sqrt(Q)*cos((theta+2*M_PI)/3) - a/3;
          x3 = -2*sqrt(Q)*cos((theta-2*M_PI)/3) - a/3;
        }
        else //equation has only one real roots
        {
          float A = -sign(R)*pow(abs(R) + sqrt(R*R - Q3), 1.0f/3.0f);
          float B = abs(A) > EPS ? Q/A : 0;
          x1 = A+B - a/3;
        }
      }
      else if (abs(c2) > 1e-4)
      {
        type = 2;
        //it is a quadratic equation a*x^2 + b*x + c = 0
        float a = c2;
        float b = c1;
        float c = c0;

        float D = b*b - 4*a*c;
        if (D > 0)
        {
          float q = -0.5f*(b + sign(b)*sqrt(D));
          x1 = q/a;
          if (abs(q) > EPS)
            x2 = c/q; 
        }
      }
      else if (abs(c1) > EPS)
      {
        type = 1;
        //it is a linear equation c1*x + c0 = 0
        x1 = -c0/c1;
      }
      //else
      //no roots or inf roots, something's fucked up so just drop it

      x1 = x1 < 0 ? 1000 : x1;
      x2 = x2 < 0 ? 1000 : x2;
      x3 = x3 < 0 ? 1000 : x3;

      //bool prev_hit = hit;
      //float nt = std::min(x1, std::min(x2,x3));
      //if (prev_hit && std::abs(t - nt) > 0.1)
      //  printf("%f-%f -- %f %f %f %f -- %f %f %f, type %u\n",t, nt, c3,c2,c1,c0, x1,x2,x3, type);
      t = min(x1, min(x2, x3));
      hit = (t >= 0 && t <= qFar);
    }
    else //if (m_preset.sdf_frame_octree_intersect == SDF_OCTREE_NODE_INTERSECT_NEWTON)
    {
      // our polynom is c3*t^3 + c2*t^2 + c1*t + c0 = 0;
      // it's derivative is  3*c3*t^2 + 2*c2*t + c1 = 0; 
      // find where it equals 0 to determine interval where the root is located
      // by solving a quadratic equation a*x^2 + b*x + c = 0
      float a = 3*c3;
      float b = 2*c2;
      float c = c1;

      float t0 = 0;
      float t1 = qFar;
      float t2 = qFar;
      float t3 = qFar;

      float D = b*b - 4*a*c;
      if (D >= 0)
      {
        float q = -0.5f*(b + sign(b)*sqrt(D));
        t1 = abs(a) > EPS ? q/a : t0;
        t2 = abs(q) > EPS ? c/q : qFar;

        float tmp = min(t1, t2);
        t2 = max(t1, t2);
        t1 = tmp;

        t1 = clamp(t1, t0, t3);
        t2 = clamp(t2, t0, t3);
      }
      
      //calculate sign of initial polynom at each critical point
      bool s0 = c0 > 0;
      bool s1 = (c0 + t1*(c1 + t1*(c2 + t1*c3))) > 0;
      bool s2 = (c0 + t2*(c1 + t2*(c2 + t2*c3))) > 0;
      bool s3 = (c0 + t3*(c1 + t3*(c2 + t3*c3))) > 0;

      //determine the range to apply Newton's method
      float nwt_min = t0;
      float nwt_max = t0;
      if (int(s0) != int(s1))
      {
        nwt_min = t0;
        nwt_max = t1;
      }
      else if (int(s1) != int(s2))
      {
        nwt_min = t1;
        nwt_max = t2;
      }
      else if (int(s2) != int(s3))
      {
        nwt_min = t2;
        nwt_max = t3;
      }

      float rtn = -100;

      if (nwt_min < nwt_max)
      {
        //perform Newton's method
        const uint max_iters = 10;
        uint iter = 0;
        rtn = 0.5f*(nwt_min + nwt_max);
        float f = 1000;
        while (iter < max_iters && abs(f) >= EPS)
        {
          f = c0 + rtn*(c1 + rtn*(c2 + rtn*c3));
          float df = c1 + rtn*(2*c2 + rtn*3*c3);
          float dx = f/(df + sign(df)*1e-9f);
          rtn -= dx;
        }
        t = rtn;
        hit = (t >= 0 && t <= qFar && abs(f) < EPS);
      }
      else
      {
        //no hit
        hit = false;
      }

      //bool prev_hit = hit;
      //float nt = rtn;
      //if (prev_hit && std::abs(t - nt) > 0.1)
      //  printf("%f-%f -- %f %f %f %f -- %f -- %f %f %f %f %d %d %d %d\n",t, nt, c3,c2,c1,c0, rtn, t0, t1, t2, t3, s0, s1, s2, s3);
    }
  }

  float tReal = fNearFar.x + 2.0f * d * t;


#if ON_CPU==1
  if (debug_cur_pixel)
  {
    printf("\n");
    printf("sdf type = %u\n", type);
    printf("node bbox [(%f %f %f)-(%f %f %f)]\n", min_pos.x, min_pos.y, min_pos.z, max_pos.x, max_pos.y, max_pos.z);
    printf("sdf values %f %f %f %f %f %f %f %f\n", 
           values[0], values[1], values[2], values[3],
           values[4], values[5], values[6], values[7]);
    printf("t = %f in [0, %f], tReal = %f in [%f %f]\n",t,qFar,tReal,fNearFar.x,fNearFar.y);
    printf("\n");
  }
#endif

  if (t <= qFar && hit && tReal < pHit.t)
  {
    vec3 norm = vec3(0,0,1);
    if (ubo.m_pAccelStruct_m_preset.need_normal > 0)
    {
      vec3 p0 = start_q + t * ray_dir;
      const float h = 0.001;
      float ddx = (m_pAccelStruct_eval_dist_trilinear(values, p0 + vec3(h,0,0)) -
                   m_pAccelStruct_eval_dist_trilinear(values, p0 + vec3(-h,0,0))) /
                  (2 * h);
      float ddy = (m_pAccelStruct_eval_dist_trilinear(values, p0 + vec3(0,h,0)) -
                   m_pAccelStruct_eval_dist_trilinear(values, p0 + vec3(0,-h,0))) /
                  (2 * h);
      float ddz = (m_pAccelStruct_eval_dist_trilinear(values, p0 + vec3(0,0,h)) -
                   m_pAccelStruct_eval_dist_trilinear(values, p0 + vec3(0,0,-h))) /
                  (2 * h);

      norm = normalize(vec3(ddx,ddy,ddz));
    }
    pHit.t = tReal;
    pHit.primId = primId;
    pHit.instId = instId;
    pHit.geomId = geomId | (type << SH_TYPE);
    pHit.coords[0] = 0;
    pHit.coords[1] = 0;
    pHit.coords[2] = norm.x;
    pHit.coords[3] = norm.y;

    if (ubo.m_pAccelStruct_m_preset.visualize_stat == VISUALIZE_STAT_SPHERE_TRACE_ITERATIONS)
      pHit.primId = iter;
  }
}

void m_pAccelStruct_IntersectRFInLeaf(const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, uint a_start, uint a_count, inout CRT_Hit pHit) {
  uint type = m_pAccelStruct_m_geomTypeByGeomId[geomId];
  uint sdfId = 0;
  uint primId = 0;

  vec3 min_pos = vec3(0,0,0), max_pos = vec3(1,1,1);

  float l = length(ray_dir);
  vec3 dir = ray_dir/l;

  BVHNode bbox = m_pAccelStruct_m_origNodes[a_start];
  vec2 zNearAndFar = RayBoxIntersection(ray_pos, dir, bbox.boxMin, bbox.boxMax);
  vec3 p = ray_pos + dir * (zNearAndFar.x + zNearAndFar.y) / 2.0f;

  vec3 lastP;
  if (pHit.adds[3] < 0.5f)
    lastP = vec3(pHit.adds[0],pHit.adds[1],pHit.adds[2]);
  else
    lastP = ray_pos + dir * zNearAndFar.x;

  float throughput = pHit.coords[0];
  vec3 colour = vec3(pHit.coords[1],pHit.coords[2],pHit.coords[3]);

  m_pAccelStruct_RayGridIntersection(ray_pos, dir, min_pos, max_pos, m_pAccelStruct_m_RFGridSizes[0], p, lastP, throughput, colour);
  
  // std::cout << throughput << std::endl;
  
  pHit.primId = a_start;
  pHit.geomId = geomId | (type << SH_TYPE);
  pHit.coords[0] = throughput;
  pHit.coords[1] = colour[0];
  pHit.coords[2] = colour[1];
  pHit.coords[3] = colour[2];
  pHit.adds[0] = p[0];
  pHit.adds[1] = p[1];
  pHit.adds[2] = p[2];
  pHit.adds[3] = 0.0f;

  // std::cout << "Mew" << std::endl;
}

void m_pAccelStruct_IntersectAllTrianglesInLeaf(const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, uint a_start, uint a_count, inout CRT_Hit pHit) {
  const uvec2 a_geomOffsets = m_pAccelStruct_m_geomOffsets[geomId];

  for (uint triId = a_start; triId < a_start + a_count; triId++)
  {
    const uint A = m_pAccelStruct_m_indices[a_geomOffsets.x + triId*3 + 0];
    const uint B = m_pAccelStruct_m_indices[a_geomOffsets.x + triId*3 + 1];
    const uint C = m_pAccelStruct_m_indices[a_geomOffsets.x + triId*3 + 2];

    const vec3 A_pos = m_pAccelStruct_m_vertPos[a_geomOffsets.y + A].xyz;
    const vec3 B_pos = m_pAccelStruct_m_vertPos[a_geomOffsets.y + B].xyz;
    const vec3 C_pos = m_pAccelStruct_m_vertPos[a_geomOffsets.y + C].xyz;

    const vec3 edge1 = B_pos - A_pos;
    const vec3 edge2 = C_pos - A_pos;
    const vec3 pvec = cross(ray_dir, edge2);
    const vec3 tvec = ray_pos - A_pos;
    const vec3 qvec = cross(tvec, edge1);

    const float invDet = 1.0f / dot(edge1, pvec);
    const float v = dot(tvec, pvec) * invDet;
    const float u = dot(qvec, ray_dir) * invDet;
    const float t = dot(edge2, qvec) * invDet;

    if (v >= -1e-6f && u >= -1e-6f && (u + v <= 1.0f + 1e-6f) && t > tNear && t < pHit.t) 
    {
      pHit.t = t;
      pHit.primId = triId;
      pHit.instId = instId;
      pHit.geomId = geomId | (TYPE_MESH_TRIANGLE << SH_TYPE);
      pHit.coords[0] = u;
      pHit.coords[1] = v;

      if (ubo.m_pAccelStruct_m_preset.need_normal > 0)
      {
        vec3 n = normalize(cross(edge1, edge2));
        pHit.coords[2] = n.x;
        pHit.coords[3] = n.y;
      }
      else
      {
        pHit.coords[2] = 0;
        pHit.coords[3] = 0;
      }
    }
  }
}

void m_pAccelStruct_IntersectAllPrimitivesInLeaf(const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, uint a_start, uint a_count, inout CRT_Hit pHit) {
  uint type = m_pAccelStruct_m_geomTypeByGeomId[geomId];
  switch (type)
  {
  case TYPE_MESH_TRIANGLE:
    m_pAccelStruct_IntersectAllTrianglesInLeaf(ray_pos, ray_dir, tNear, instId, geomId, a_start, a_count, pHit);
    break;
  case TYPE_SDF_PRIMITIVE:
  case TYPE_SDF_GRID:
  case TYPE_SDF_OCTREE:
    m_pAccelStruct_IntersectAllSdfsInLeaf(ray_pos, ray_dir, tNear, instId, geomId, a_start, a_count, pHit);
    break;
  case TYPE_SDF_FRAME_OCTREE:
    if (ubo.m_pAccelStruct_m_preset.sdf_frame_octree_intersect == SDF_OCTREE_NODE_INTERSECT_DEFAULT)
      m_pAccelStruct_IntersectAllSdfsInLeaf(ray_pos, ray_dir, tNear, instId, geomId, a_start, a_count, pHit);
    else
      m_pAccelStruct_OctreeNodeIntersect(type, ray_pos, ray_dir, tNear, instId, geomId, a_start, a_count, pHit);
    break;
  case TYPE_RF_GRID:
    m_pAccelStruct_IntersectRFInLeaf(ray_pos, ray_dir, tNear, instId, geomId, a_start, a_count, pHit);
    break;
  case TYPE_SDF_SVS:
  case TYPE_SDF_SBS:
    m_pAccelStruct_OctreeNodeIntersect(type, ray_pos, ray_dir, tNear, instId, geomId, a_start, a_count, pHit);
    break;
  default:
    break;
  }
}

void m_pAccelStruct_BVH2TraverseF32(const vec3 ray_pos, const vec3 ray_dir, float tNear, uint instId, uint geomId, inout uint32_t stack[STACK_SIZE], bool stopOnFirstHit, inout CRT_Hit pHit) {
  const uint bvhOffset = m_pAccelStruct_m_bvhOffsets[geomId];

  int top = 0;
  uint leftNodeOffset = 0;

  const vec3 rayDirInv = SafeInverse(ray_dir);
  while (top >= 0 && !(stopOnFirstHit && pHit.primId != uint32_t(-1)))
  {
    while (top >= 0 && ((leftNodeOffset & LEAF_BIT) == 0))
    {
      const BVHNodePair fatNode = m_pAccelStruct_m_allNodePairs[bvhOffset + leftNodeOffset];

      const uint node0_leftOffset = fatNode.left.leftOffset;
      const uint node1_leftOffset = fatNode.right.leftOffset;

      const vec2 tm0 = RayBoxIntersection2(ray_pos, rayDirInv, fatNode.left.boxMin, fatNode.left.boxMax);
      const vec2 tm1 = RayBoxIntersection2(ray_pos, rayDirInv, fatNode.right.boxMin, fatNode.right.boxMax);

      const bool hitChild0 = (tm0.x <= tm0.y) && (tm0.y >= tNear) && (tm0.x <= pHit.t);
      const bool hitChild1 = (tm1.x <= tm1.y) && (tm1.y >= tNear) && (tm1.x <= pHit.t);

      // traversal decision
      leftNodeOffset = hitChild0 ? node0_leftOffset : node1_leftOffset;

      if (hitChild0 && hitChild1)
      {
        leftNodeOffset = (tm0.x <= tm1.x) ? node0_leftOffset : node1_leftOffset; // GPU style branch
        stack[top]     = (tm0.x <= tm1.x) ? node1_leftOffset : node0_leftOffset; // GPU style branch
        top++;
      }

      if (!hitChild0 && !hitChild1) // both miss, stack.pop()
      {
        top--;
        leftNodeOffset = stack[max(top, 0)];
      }

    } // end while (searchingForLeaf)

    // leaf node, intersect triangles
    //
    if (top >= 0 && leftNodeOffset != 0xFFFFFFFF)
    {
      const uint start = EXTRACT_START(leftNodeOffset);
      const uint count = EXTRACT_COUNT(leftNodeOffset);
      m_pAccelStruct_IntersectAllPrimitivesInLeaf(ray_pos, ray_dir, tNear, instId, geomId, start, count, pHit);
    }

    // continue BVH traversal
    //
    top--;
    leftNodeOffset = stack[max(top, 0)];

  } // end while (top >= 0)

}

CRT_Hit m_pAccelStruct_RayQuery_NearestHit(vec4 posAndNear, vec4 dirAndFar) {
  bool stopOnFirstHit = (dirAndFar.w <= 0.0f);
  if(stopOnFirstHit)
    dirAndFar.w *= -1.0f;
  const vec3 rayDirInv = SafeInverse(dirAndFar.xyz);

  uint32_t stack[STACK_SIZE];

  CRT_Hit hit;
  hit.t      = dirAndFar.w;
  hit.primId = uint32_t(-1);
  hit.instId = uint32_t(-1);
  hit.geomId = uint32_t(-1);
  hit.coords[0] = 1.0f;
  hit.coords[1] = 0.0f;
  hit.coords[2] = 0.0f;
  hit.coords[3] = 0.0f;
  hit.adds[0] = 0.0f;
  hit.adds[1] = 0.0f;
  hit.adds[2] = 0.0f;
  hit.adds[3] = 1.0f;

  // std::cout << "-----------------------------------------" << std::endl;

  //no TLAS, only one instance
  if (ubo.m_pAccelStruct_m_nodesTLAS_size == 1)
  {
    const vec2 boxHit = RayBoxIntersection2(posAndNear.xyz, rayDirInv, m_pAccelStruct_m_nodesTLAS[0].boxMin, m_pAccelStruct_m_nodesTLAS[0].boxMax);
    const bool intersects = (boxHit.x <= boxHit.y) && (boxHit.y > posAndNear.w);
    if (intersects)
    {
      const uint instId = 0;
      const uint geomId = m_pAccelStruct_m_geomIdByInstId[instId];

      // transform ray with matrix to local space
      const vec3 ray_pos = matmul4x3(m_pAccelStruct_m_instMatricesInv[0], posAndNear.xyz);
      const vec3 ray_dir = matmul3x3(m_pAccelStruct_m_instMatricesInv[0], dirAndFar.xyz);
      m_pAccelStruct_BVH2TraverseF32(ray_pos, ray_dir, posAndNear.w, instId, geomId, stack, stopOnFirstHit, hit);
    }
  }
  else
  {
    uint nodeIdx = 0;
    do
    {
      uint travFlags = 0;
      uint leftOffset = 0;
      do
      {
        const BVHNode currNode = m_pAccelStruct_m_nodesTLAS[nodeIdx];
        const vec2 boxHit = RayBoxIntersection2(posAndNear.xyz, rayDirInv, currNode.boxMin, currNode.boxMax);
        const bool intersects = (boxHit.x <= boxHit.y) && (boxHit.y > posAndNear.w) && (boxHit.x < hit.t); // (tmin <= tmax) && (tmax > 0.f) && (tmin < curr_t)

        travFlags  = (currNode.leftOffset & LEAF_BIT) | uint32_t(intersects); // travFlags  = (((currNode.leftOffset & LEAF_BIT) == 0) ? 0 : LEAF_BIT) | (intersects ? 1 : 0);
        leftOffset = currNode.leftOffset;
        nodeIdx    = isLeafOrNotIntersect(travFlags) ? currNode.escapeIndex : leftOffset;

      } while (notLeafAndIntersect(travFlags) && nodeIdx != 0 && nodeIdx < 0xFFFFFFFE); 
      
      if(isLeafAndIntersect(travFlags)) 
      {
        const uint instId = EXTRACT_START(leftOffset);
        const uint geomId = m_pAccelStruct_m_geomIdByInstId[instId];
    
        // transform ray with matrix to local space
        //
        const vec3 ray_pos = matmul4x3(m_pAccelStruct_m_instMatricesInv[instId], posAndNear.xyz);
        const vec3 ray_dir = matmul3x3(m_pAccelStruct_m_instMatricesInv[instId], dirAndFar.xyz); // DON'float NORMALIZE IT !!!! When we transform to local space of node, ray_dir must be unnormalized!!!
    
        m_pAccelStruct_BVH2TraverseF32(ray_pos, ray_dir, posAndNear.w, instId, geomId, stack, stopOnFirstHit, hit);
      }
    } while (nodeIdx < 0xFFFFFFFE && !(stopOnFirstHit && hit.primId != uint32_t(-1))); //
  }

  if(hit.geomId < uint32_t(-1) && ((hit.geomId >> SH_TYPE) == TYPE_MESH_TRIANGLE)) 
  {
    const uvec2 geomOffsets = m_pAccelStruct_m_geomOffsets[hit.geomId & 0x0FFFFFFF];
    hit.primId = m_pAccelStruct_m_primIndices[geomOffsets.x/3 + hit.primId];
  }
  
  return hit;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;
layout( push_constant ) uniform kernelArgs
{
  uint iNumElementsX; 
  uint iNumElementsY; 
  uint iNumElementsZ; 
  uint tFlagsMask;    
} kgenArgs;

///////////////////////////////////////////////////////////////// subkernels here
void kernel_RayTrace_out_color(uint tidX, in vec4 rayPosAndNear, in vec4 rayDirAndFar, uint out_colorOffset) 
{
  
  const vec4 rayPos = rayPosAndNear;
  const vec4 rayDir = rayDirAndFar ;
  const uint XY = m_packedXY[tidX];
  const uint x  = (XY & 0x0000FFFF);
  const uint y  = (XY & 0xFFFF0000) >> 16;

#if ON_CPU==1
  //if (x == 484 && y == 526)
  //  m_pAccelStruct->set_debug_mode(true);
  //else
  //  m_pAccelStruct->set_debug_mode(false);
#endif

  CRT_Hit hit = m_pAccelStruct_RayQuery_NearestHit(rayPos, rayDir);

  if (hit.primId == 0xFFFFFFFF) //no hit
  {
    out_color[y * ubo.m_width + x + out_colorOffset] = 0;
    return;
  }
  else
  {
    vec3 norm = vec3(hit.coords[2],hit.coords[3],sqrt(max(0.0f, 1-hit.coords[2]*hit.coords[2] - hit.coords[3]*hit.coords[3])));
    float q = max(0.1f, dot(norm, normalize(vec3(1,1,1))));
    uint col = uint32_t(255*q);
    out_color[y * ubo.m_width + x + out_colorOffset] = 0xFF000000 | (col<<16) | (col<<8) | col;
    //out_color[y * m_width + x] = m_palette[(hit.primId) % palette_size];
  } 

  float z = hit.t;
  float z_near = 0.1;
  float z_far = 10;
  out_color[y * ubo.m_width + x + out_colorOffset] = 0xFFFF00FF; //if pixel is purple at the end, then something gone wrong!
  switch (ubo.m_preset.mode)
  {
    case MULTI_RENDER_MODE_MASK:
    out_color[y * ubo.m_width + x + out_colorOffset] = 0xFFFFFFFF;
    break;

    case MULTI_RENDER_MODE_LAMBERT:
    {
      vec3 norm = vec3(hit.coords[2],hit.coords[3],sqrt(max(0.0f, 1-hit.coords[2]*hit.coords[2] - hit.coords[3]*hit.coords[3])));
      float q = max(0.1f, dot(norm, normalize(vec3(1,1,1))));
      uint col = uint32_t(255*q);
      out_color[y * ubo.m_width + x + out_colorOffset] = 0xFF000000 | (col<<16) | (col<<8) | col;      
    }
    break;

    case MULTI_RENDER_MODE_DEPTH:
    {
      float d = (1 / z - 1 / z_near) / (1 / z_far - 1 / z_near);
      uint col = uint32_t(255*d);
      out_color[y * ubo.m_width + x + out_colorOffset] = 0xFF000000 | (col<<16) | (col<<8) | col;   
    }
    break;

    case MULTI_RENDER_MODE_LINEAR_DEPTH:
    {
      float d = ((z - z_near) / (z_far - z_near));
      uint col = uint32_t(255*d);
      out_color[y * ubo.m_width + x + out_colorOffset] = 0xFF000000 | (col<<16) | (col<<8) | col;   
    }
    break;

    case MULTI_RENDER_MODE_INVERSE_LINEAR_DEPTH:
    {
      float d = 1 - ((z - z_near) / (z_far - z_near));
      uint col = uint32_t(255*d);
      out_color[y * ubo.m_width + x + out_colorOffset] = 0xFF000000 | (col<<16) | (col<<8) | col;   
    }
    break;

    case MULTI_RENDER_MODE_PRIMIVIVE:
    out_color[y * ubo.m_width + x + out_colorOffset] = m_palette[(hit.primId) % palette_size];
    break;

    case MULTI_RENDER_MODE_TYPE:
    {
    uint type = hit.geomId >> SH_TYPE;
      out_color[y * ubo.m_width + x + out_colorOffset] = m_palette[type % palette_size];
    }
    break;

    case MULTI_RENDER_MODE_GEOM:
    {
      uint geomId = hit.geomId & 0x0FFFFFFF;
      out_color[y * ubo.m_width + x + out_colorOffset] = m_palette[geomId % palette_size];
    }
    break;

    case MULTI_RENDER_MODE_NORMAL:
    {
      vec3 norm = vec3(hit.coords[2],hit.coords[3],sqrt(max(0.0f, 1-hit.coords[2]*hit.coords[2] - hit.coords[3]*hit.coords[3])));
      uvec3 col = uvec3(255*abs(norm));
      out_color[y * ubo.m_width + x + out_colorOffset] = 0xFF000000 | (col.z<<16) | (col.y<<8) | col.x; 
    }
    break;

    case MULTI_RENDER_MODE_BARYCENTRIC:
    {
      uvec3 col = uvec3(255*vec3(hit.coords[0],hit.coords[1],1-hit.coords[0]-hit.coords[1]));
      out_color[y * ubo.m_width + x + out_colorOffset] = 0xFF000000 | (col.z<<16) | (col.y<<8) | col.x; 
    }
    break;
    case MULTI_RENDER_MODE_SPHERE_TRACE_ITERATIONS:
    {
      vec3 c1 = vec3(0,1,0);
      vec3 c2 = vec3(1,0,0);
      float q = clamp(0.01f*float(hit.primId), 0.0f,1.0f);
      uvec3 col = uvec3(255*(q*c1 + (1-q)*c2));
      out_color[y * ubo.m_width + x + out_colorOffset] = 0xFF000000 | (col.z<<16) | (col.y<<8) | col.x; 
    }
    break;
    case MULTI_RENDER_MODE_RF:
    {
      uvec3 col = uvec3(255 * vec3(hit.coords[1],hit.coords[2],hit.coords[3]));
      out_color[y * ubo.m_width + x + out_colorOffset] = 0xFF000000 | (col.z<<16) | (col.y<<8) | col.x;
    }
    break;
    default:
    break;
  }

}

void kernel_InitEyeRay(uint tidX, inout vec4 rayPosAndNear, inout vec4 rayDirAndFar) 
{
  
  const uint XY = m_packedXY[tidX];
  const uint x  = (XY & 0x0000FFFF);
  const uint y  = (XY & 0xFFFF0000) >> 16;
  
  //if(x == 37 && y == 450)
  //{
  //  g_debugPrint = true;
  //}
  //else
  //  g_debugPrint = false;

  vec3 rayDir = EyeRayDirNormalized((float(x)+0.5f)/float(ubo.m_width), (float(y)+0.5f)/float(ubo.m_height), ubo.m_projInv);
  vec3 rayPos = vec3(0,0,0);

  transform_ray3f(ubo.m_worldViewInv, 
                  rayPos, rayDir);
  
  rayPosAndNear = vec4(rayPos, 0.0f);
  rayDirAndFar  = vec4(rayDir, 1e9f);

}

///////////////////////////////////////////////////////////////// subkernels here

void main()
{
  ///////////////////////////////////////////////////////////////// prolog
  const uint tidX = uint(gl_GlobalInvocationID[0]); 
  ///////////////////////////////////////////////////////////////// prolog

  
  //const uint XY = m_pakedXY[tidX];
  //const uint x  = (XY & 0x0000FFFF);
  //const uint y  = (XY & 0xFFFF0000) >> 16;
  //if(x >= 50 && y == 450)
  //{
  //  int a = 2; // put debug breakpoint here
  //}
  vec4 rayPosAndNear,  rayDirAndFar;
  kernel_InitEyeRay(tidX, rayPosAndNear, rayDirAndFar);
  kernel_RayTrace_out_color(tidX, rayPosAndNear, rayDirAndFar, 0);

}

